@page "/editNote/{templateIndex}"

@using Markdig
@using NotesRepository.Data.Models
@using NotesRepository.Repositories
@using NotesRepository.Services
@using System.Security.Claims
@using System.ComponentModel.DataAnnotations;
@using Data.Constants;

@inject Microsoft.AspNetCore.Http.IHttpContextAccessor httpContextAccessor
@inject Microsoft.Extensions.Localization.IStringLocalizer<Resource> localizer
@inject NavigationManager navigationManager
@inject NoteService _ns;
@inject UserRepository _ur;
@inject ImageService _is;
@inject DirectoryService _ds;
@inject IToastService toastService;

@if (content is null || imagesFromUser is null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div class="my-container">
        <div class="my-sub-container p-2 ">
            <center><h3>@localizer["content"]</h3> </center>
            <textarea class="my-text-area" @bind-value="content" @bind-value:event="oninput"></textarea>
            <center>
                <row>
                    <colulmn>
                        <InputFile OnChange="@LoadFile" accept=".jpg, .png"/>
                    </colulmn>
                    <colulmn>
                        <button type="button" class="btn btn-primary" @onclick="saveNote">@localizer["save"]</button>
                    </colulmn>
                </row>
            </center>
        </div>
        <div class="my-sub-container p-2">
            <center><h3>@localizer["preview"]</h3></center>
            <div class="my-preview">
                @((MarkupString)Markdown.ToHtml(content, pipeline))
            </div>
        </div>
            <center>
            @if(imagesFromUser.Count > 0)
            {
                <div>
                        <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Image</th>
                                <th>URL</th>
                            </tr>
                        </thead>
                        <tbody>
                        @foreach(var image in imagesFromUser)
                        { 
                            <tr>
                                <th>@image.Name</th>
                                <th>@image.FileUrl</th>
                                <th><button type="button" class="btn btn-primary" @onclick="() => deleteImageFromNote(image)">@localizer["delete"]</button></th>
                            </tr>        
                        }
                        </tbody>
                    </table>
                </div>
            }
            </center>
    </div>
}

@code
{
    [Parameter]
    public string templateIndex { get; set; }
    private string content = "";
    private MarkdownPipeline? pipeline;
    private bool validId = false;
    private Guid parsedId;
    private List<Image> imagesFromUser;

    protected override async Task OnParametersSetAsync()
    {
        imagesFromUser = new List<Image>();
        content = templateIndex == "newNote" ? "" : await init();
        pipeline = new MarkdownPipelineBuilder().UseAdvancedExtensions().Build(); // Uruchomienie rozszerzeń markdown
    }

    private async Task saveNote()
    {
        if (content.Length <= 0)
        {
            toastService.ShowError("Your note is empty.", "OOPS!");
        }
        else
        {
            string? currentUserId = httpContextAccessor.HttpContext!.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (currentUserId != null)
            {
                var usr = await _ur.GetUserByIdAsync(currentUserId);
                var folder = await _ds.GetDefaultDirectoryForParticularUserAsync(usr.Id);
                if (usr is not null && folder is not null)
                {
                    // TODO narazie każda notatka będzie zapisywana w folderze default
                    var result = await _ns.AddNoteAsync(new Note(null, "newNote", content, "", usr, folder));
                    if (result)
                        toastService.ShowSuccess("The note was saved.", "Congrats!");
                }
            }

        }
    }

    private async Task<string> init() // TODO narazie init obsługuje tylko wczytywanie templateów, trzeba dodać obsługę wczytywania z bazy
    {
        if (templateIndex is not null)
        {
            validId = Guid.TryParse(templateIndex, out parsedId);
            if (validId == false)
            {
                return Templates.NotesTemplates[templateIndex];
            }
            else
            {
                string? currentUserId = httpContextAccessor.HttpContext!.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                if (currentUserId != null)
                {
                    var note = await _ns.GetNoteByIdAsync(Guid.Parse(templateIndex));
                    if (note is not null)
                    {
                        var noteImages = await _is.GetAllUserImagesAsync(currentUserId);
                        if (noteImages.Count > 0)
                        {
                            foreach (var image in noteImages)
                            {
                                imagesFromUser.Add(image);
                            }
                        }
                        return note.Content;
                    }
                    else
                    {
                        return " ";
                    }
                }
                else
                {
                    return " ";
                }
            }
        }
        else
        {
            return " ";
        }
    }

    private async void LoadFile(InputFileChangeEventArgs e) // TODO wprowadzanie więcej niż jednego pliku
    {
        var image = await e.File.RequestImageFileAsync("image/jpg", 1920, 1080);
        if (image != null)
        {
            string? currentUserId = httpContextAccessor.HttpContext!.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (currentUserId != null)
            {
                var loggedUser = await _ur.GetUserByIdAsync(currentUserId);
                var Notes = await _ns.GetAllUserNotesByIdAsync(loggedUser!.Id);
                Image newImage;
                if (Notes.Count > 0)
                {
                    var uniqueImageName = /* generateUniqueCharacters() + */ image.Name;    // TODO unikalna ścieżka
                    newImage = new Image(null, uniqueImageName, "", Notes[0]);              // TODO W aktualnie wersji każda zdjęcie jest przypisaywana tej samej notatki
                    var resultAndUrl = await _is.AddImageAsync(newImage, image);            // First element is bool value, second is a url to image
                    if (resultAndUrl.Item1)
                    {
                        content += $"\n![{image.Name}]({resultAndUrl.Item2})\n";
                        imagesFromUser.Add(newImage);
                        this.StateHasChanged();
                    }
                }
            }
        }
        else
        {
            toastService.ShowError("A wrong file has been entered.", "OOPS!");
        }
    }

    // TODO usuwanie zdjęcia z danej notatki -> przycisk w tabeli -> usuwanie zdjęcia z Azure
    private async void deleteImageFromNote(Image image)
    {
        string? currentUserId = httpContextAccessor.HttpContext!.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        if (currentUserId != null)
        {
            try
            {
                var result = await _is.DeleteImageAsync(image);
                if (result)
                {
                    toastService.ShowSuccess("Image has been deleted");
                    imagesFromUser.Remove(image);
                }
                else
                {
                    toastService.ShowError("Something went wrong!");
                }
                this.StateHasChanged();
            }
            catch(Exception e)
            {
                // DEBUG potem mnie proszę usunąć
                toastService.ShowError(e.Message);
            }
        }
    }

    private string generateUniqueCharacters()
    {
        string guid = Guid.NewGuid().ToString();
        var split = guid.Split('-');
        return split[0];
    }
}